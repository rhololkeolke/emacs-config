# -*- coding: utf-8 -*-
#+TITLE: Emacs init file written in org-mode
#+AUTHOR: Devin Schwab
#+EMAIL: digidevin@gmail.com
#+STARTUP: indent

#+BEGIN_SRC emacs-lisp
  (message "Tangling org-init.org file.")
#+END_SRC

* Global Improvements
** Customize Group
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Creating customize group rhol-emacs/rhol-general")
  (defgroup rhol-general nil
    "General customization settings."
    :group 'rhol-emacs
    :tag "General")
#+END_SRC
** Emacs Server

Start Emacs server if not already running.
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Emacs Server")
  (add-hook 'after-init-hook
            (lambda ()
              "Start Emacs server if not already running."
              (use-package server
                :config
                (unless (server-running-p)
                  (server-start)))))
#+END_SRC
** Bash Environment
Set Emacs environment variables to the same values that a user would
have after sourcing .bash_profile.
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Bash Environment")

  (defun rhol--get-bash-env ()
    "Return the environment variable string set by .bash_profile."
    (shell-command-to-string "/bin/bash -c \"source ~/.bash_profile; env\""))

  (defun rhol--apply-env-string (raw-env-str)
    "Set environment variables from env string.
  
    RAW-ENV-STR the output of env command"
    (let ((env-strings (split-string raw-env-str "\n")))
      (setq process-environment env-strings)))

  (defun rhol-eval-bash-env ()
    "Overwrite `process-environment' with the environment variables set by .bash_profile."
    (interactive)
    (rhol--apply-env-string (rhol--get-bash-env)))

  (defun rhol--get-bash-path ()
    "Return PATH variable after evaluating bash profile."
    (replace-regexp-in-string "\n" ""
                              (shell-command-to-string "/bin/bash -c \"source ~/.bash_profile >/dev/null 2>&1; echo $PATH\"")))

  (defun rhol-eval-bash-path ()
    "Set exec path based on bash path variable."
    (interactive)
    (let ((env-strings (split-string (rhol--get-bash-path) ":")))
      (setq exec-path env-strings)))

  (rhol-eval-bash-env)
  (rhol-eval-bash-path)
#+END_SRC

** Open Default Directory

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Open Default Directory")

  (defun rhol-open-default-directory ()
    "Open the directory of the current buffer.

    Useful for quickly opening a dired buffer for the containing
    folder of the current buffer."
    (interactive)
    (find-file (file-name-directory buffer-file-name)))

  (global-set-key (kbd "C-x C-j") 'rhol-open-default-directory)
#+END_SRC
** General Keybindings

Useful key bindings. Deals with clipboard integration and
disabling C-z.

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: General Keybindings")
  ;; unbind the sleep button
  (global-unset-key [(control z)])
  (global-unset-key [(control x)(control z)])

  ;; Windows Style undo
  (global-set-key (kbd "s-z") 'undo)

  ;; Windows Style cut, copy and paste
  (global-set-key (kbd "s-c") 'clipboard-kill-ring-save)
  (global-set-key (kbd "s-x") 'clipboard-kill-region)
  (global-set-key (kbd "s-v") 'clipboard-yank)

  ;; quickly enable and disable auto-fill-mode
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC

** Common Lisp Package

Required library for a lot of the packages in the following sections.

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Common Lisp package")
  (use-package cl
    :ensure t)
#+END_SRC
** General Tweaks

Lots of handy little quality of life improvements.

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: General Tweaks")
  ;; enable line highlighting
  (global-hl-line-mode t)

  ;; get rid of yes or no prompt
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; remove confirmation if file or buffer does not exist
  (setq confirm-nonexistent-file-or-buffer nil)
  ;; remove splash screen and echo area message
  (setq inhibit-startup-message t inhibit-startup-echo-area-message t)

  ;; Add autofill for all text mode buffers
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Sudo Edit

When a buffer requires sudo privileges to edit, this function allows
the user to press =C-x C-r= to reload the buffer with sudo privileges.
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Sudo Edit")
  ;; Allow editing of a buffer that requires sudo privileges
  (defun sudo-edit (&optional arg)
    "Edit currently visited file as root.

  With a prefix ARG prompt for a file to visit.
  Will also prompt for a file to visit if current
  buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (ido-read-file-name "Find file(as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
  (global-set-key (kbd "C-x C-r") 'sudo-edit)
#+END_SRC
** Spellcheck
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Spellcheck")

  (defcustom rhol-default-spellchecker "hunspell"
    "Executable name for default spellchecker."
    :type '(choice (string :tag "hunspell" :value "hunspell")
                   (string :tag "aspell" :value "aspell")
                   (string :tag "Custom"))
    :group 'rhol-general
    :tag "Default spellchecker")

  (defcustom rhol-default-spellchecker-args '("-d en_US")
    "List of extra args to provide to spellchecker."
    :type 'list
    :group 'rhol-general
    :tag "Default spellchecker args")

  (defun rhol--config-spellchecker ()
    "Configure spellchecker using saved config."
    (if (executable-find rhol-default-spellchecker)
        (progn
          (setq ispell-program-name rhol-default-spellchecker)
          (setq ispell-extra-args rhol-default-spellchecker-args)
          (if (string= "aspell" rhol-default-spellchecker)
              (setq ispell-list-command "--list")))
      (user-error "Default spellchecker %s not found" rhol-default-spellchecker)))

  (rhol--config-spellchecker)
#+END_SRC
* Appearance
** Customize Group
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Creating customize group rhol-emacs/rhol-appearance")
  (defgroup rhol-appearance nil
    "Appearance customization settings."
    :group 'rhol-emacs
    :tag "Appearance")
#+END_SRC
** Font
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Font")

  (defcustom rhol-default-font nil
    "Font name used in graphical mode."
    :type 'string
    :group 'rhol-appearance
    :tag "Default Font")

  (if rhol-default-font
      nil
    (customize-save-variable 'rhol-default-font
                             (let ((choice (completing-read "What font do you want to use? ((D)efault, (I)nconsolata, (S)ource Code Pro, (O)ther): "
                                                            '(("D" 1)
                                                              ("I" 2)
                                                              ("S" 3)
                                                              ("O" 4))
                                                            nil t "D")))
                               (cond
                                ((string= choice "D")
                                 "DejaVu Sans Mono")
                                ((string= choice "I")
                                 "Inconsolata")
                                ((string= choice "S")
                                 "Source Code Pro")
                                ((string= choice "O")
                                 (read-string "Enter desired font-name: "))))))

  (defcustom rhol-default-font-size nil
    "Font size used in graphical mode."
    :type 'integer
    :group 'rhol-appearance
    :tag "Font Size")

  (if rhol-default-font-size
      nil
    (customize-save-variable 'rhol-default-font-size
                             (read-number "Enter font size: " 9)))

  (defun rhol--configure-font ()
    "Refresh font configuration."
    (if (member rhol-default-font (font-family-list))
        (let ((font-name (format "%s-%d" rhol-default-font rhol-default-font-size)))
        (add-to-list 'initial-frame-alist (cons 'font font-name))
        (add-to-list 'default-frame-alist (cons 'font font-name)))
      (user-error "Font %s does not exist" rhol-default-font)))

  (rhol--configure-font)
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Theme")
  (use-package darkokai-theme
    :ensure t
    :config
    (add-to-list 'custom-safe-themes "196cc00960232cfc7e74f4e95a94a5977cb16fd28ba7282195338f68c84058ec")
    (load-theme 'darkokai-custom t))
#+END_SRC
** Emojis

#+BEGIN_SRC emacs-lisp
  (message "loading emojify")
  (use-package emojify
    :ensure t
    :config
    (emojify-download-emoji-maybe)
    (add-hook 'after-init-hook #'global-emojify-mode))
#+END_SRC
** Disable Toolbars

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)
#+END_SRC
* Third-Party Packages
** Customize Group
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Creating customize group rhol-emacs/rhol-appearance")
  (defgroup rhol-third-party nil
    "Enable and disable third-party packages."
    :group 'rhol-emacs
    :tag "Third-Party Packages")
#+END_SRC
** ibuffer

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: ibuffer")
  (defcustom rhol-use-ibuffer t
    "Set true to enable ibuffer package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use ibuffer")

  (if rhol-use-ibuffer
      (use-package ibuffer
        :ensure t
        :config
        (global-set-key (kbd "C-x C-b") 'ibuffer)
        (setq ibuffer-saved-filters
              '(("C/C++" ((or (mode . c++-mode)
                              (mode . c-mode)
                              (mode . cmake-mode))))
                ("Python" ((mode . python-mode)))
                ("Emacs" ((or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$"))))
                ("Org" ((or
                         (name . "^\\*Org Agenda\\*$")
                         (mode . org-mode))))
                ("Dired" ((mode . dired-mode)))
                ("Helm" ((name . "^\\*helm")))
                ("Magit" ((name . "^\\*magit")))))
        (setq ibuffer-saved-filter-groups
              '(("Default"
                 ("Dired" (mode . dired-mode))
                 ("Python" (mode . python-mode))
                 ("Org" (or
                         (name . "^\\*Org Agenda\\*$")
                         (mode . org-mode)))
                 ("C/C++" (or
                           (mode . c++-mode)
                           (mode . c-mode)
                           (mode . cmake-mode)))
                 ("Emacs" (or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$")))
                 ("Helm" (name . "^\\*helm"))
                 ("Magit" (name . "^\\*magit")))))
        (add-hook 'ibuffer-mode-hook (lambda () (ibuffer-switch-to-saved-filter-groups "Default")))))
#+END_SRC
** Direnv

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: direnv")
  (defcustom rhol-use-direnv t
    "Set true to enable direnv parsing."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use direnv")

  (defun rhol--find-envrc (path)
    "Find path to .envrc.

    PATH path to the buffer that you want to find .envrc for."
    (locate-dominating-file path ".envrc"))

  (defun rhol--get-direnv-str (envrc-path)
    "Get the direnv environment vars.

    ENVRC-PATH path to the .envrc to load."
    (message "%s" envrc-path)
    (make-local-variable 'process-environment)
    (shell-command-to-string (format "pushd %s > /dev/null; source .envrc; /usr/bin/env" envrc-path)))

  (defun rhol-unload-direnv ()
    "Unload changed env from direnv."
    (interactive)
    (if (local-variable-p 'process-environment)
        (kill-local-variable 'process-environment)))

  (defun rhol-load-direnv-for-buffer ()
    "Parse environment specified by direnv for a given buffer."
    (interactive)
    (cond
     ;; Special handling of dired mode files
     ((eq 'dired-mode major-mode)
      (let ((envrc-path (rhol--find-envrc (expand-file-name default-directory))))
        (message "%s" envrc-path)
        (if envrc-path
            (let ((env-str (rhol--get-direnv-str envrc-path)))
              (message "%s" env-str)
              (rhol--apply-env-string env-str)))))
     ;; Other files can be handled normally
     (t
      (let ((envrc-path (rhol--find-envrc (buffer-file-name))))
        (if envrc-path
            (let ((env-str (rhol--get-direnv-str envrc-path)))
              ;; (message "%s" env-str)
              (rhol--apply-env-string env-str)))))))

  (if rhol-use-direnv
      (add-hook 'find-file-hook 'rhol-load-direnv-for-buffer))
#+END_SRC
** Ace Window
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: ace-window")
  (defcustom rhol-use-ace-window t
    "Set true to enable ace-window package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use ace-window")
  (if rhol-use-ace-window
      (use-package ace-window
        :ensure t))
#+END_SRC
** Ripgrep

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: ripgrep")
  (defcustom rhol-use-ripgrep t
    "Set true to enable ripgrep package if rg installed on system."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use ripgrep")
  (if rhol-use-ripgrep
      (if (executable-find "cargo")
          (use-package rg
            :ensure t
            :ensure-system-package 
            (rg . "cargo install --force ripgrep")
            :config (rg-enable-default-bindings))
        (message "cargo not installed. Skipping rg package.")))
#+END_SRC
** Flyspell
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: flyspell")
  (defcustom rhol-use-flyspell t
    "Set true to enable flyspell package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use flyspell")
  (if rhol-use-flyspell
      (use-package flyspell
        :ensure t
        :config (add-hook 'org-mode-hook '(lambda () (flyspell-mode)))))
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Flycheck")

  (defcustom rhol-use-flycheck t
    "Set true to enable flycheck package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use flycheck")

  (if rhol-use-flycheck
      (use-package flycheck
        :ensure t
        :config
        (add-hook 'after-init-hook #'global-flycheck-mode)))
#+END_SRC

** YASnippets

Autofill snippets for various modes.
[[https://capitaomorte.github.io/yasnippet/][https://capitaomorte.github.io/yasnippet/]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: YASnippets")
    (defcustom rhol-use-yasnippet t
      "Set true to enable yasnippet package."
      :type 'boolean
      :group 'rhol-third-party
      :tag "Use yasnippet")

  (if rhol-use-yasnippet
      (use-package yasnippet
        :ensure t
        :config
        (yas-global-mode 1)
        (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")))
#+END_SRC

** Company

Autocomplete module. See [[https://company-mode.github.io/][https://company-mode.github.io/]]


#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Company")

  (defcustom rhol-use-company t
    "Enable use of company package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Enable company")

  (if rhol-use-company
      (use-package company
        :ensure t
        :config
        (setq company-idle-delay 0.5)
        (add-hook 'after-init-hook 'global-company-mode)
        (global-set-key (kbd "C-<tab>") 'company-complete-common)
        (company-auctex-init)
        (add-to-list 'company-backends 'company-math-symbols-unicode)))

#+END_SRC
** Helm

Auto-completion library
[[https://emacs-helm.github.io/helm/][https://emacs-helm.github.io/helm/]]

*** Basic Config

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Helm")
  (defun rhol/helm-config ()
    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z") 'helm-select-action)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-split-window-in-side-p           t ; open helm buffer inside current window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when
                                          ;      reaching top or bottom of source
          helm-ff-search-library-in-sexp        t ; search for library in `require` and `declare-function` sexp
          helm-scroll-amount                    8 ; scroll 8 lines
          helm-ff-file-name-history-use-recentf t)

    (helm-mode 1)

    ;; Replace normal M-x
    (global-set-key (kbd "M-x") 'helm-M-x)
    (setq helm-M-x-fuzzy-match t)

    ;; Replace normal kill-ring cycle
    (global-set-key (kbd "M-y") 'helm-show-kill-ring)

    ;; Replace normal find files
    (global-set-key (kbd "C-x C-f") 'helm-find-files))

  (use-package helm
    :ensure t
    :config
    (use-package helm-config)
    (rhol/helm-config))
#+END_SRC

*** Helm swoop

Buffer search with Helm
[[https://github.com/ShingoFukuyama/helm-swoop][https://github.com/ShingoFukuyama/helm-swoop]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Helm Swoop")
  (use-package helm-swoop
    :ensure t
    :config
    (global-set-key (kbd "M-i") 'helm-swoop)
    (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
    (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
    (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch) ; when doing isearch, hand the word over to helm-swoop
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
#+END_SRC

** Smartparens

Smartparens is a minor mode for dealing with pairs of delimiters. More
info can be found at [[https://github.com/Fuco1/smartparens][https://github.com/Fuco1/smartparens]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Smartparens")
  (use-package smartparens-config
    :ensure smartparens
    :config
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)
    (defun wrap-with-parens ()
      (sp-wrap-with-pair "("))
    (bind-keys
     :map smartparens-mode-map
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)

     ("C-<down>" . sp-down-sexp)
     ("C-<up>"   . sp-up-sexp)
     ("M-<down>" . sp-backward-down-sexp)
     ("M-<up>"   . sp-backward-up-sexp)

     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)

     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)

     ("C-S-f" . sp-forward-symbol)
     ("C-S-b" . sp-backward-symbol)

     ("C-<right>" . sp-forward-slurp-sexp)
     ("M-<right>" . sp-forward-barf-sexp)
     ("C-<left>"  . sp-backward-slurp-sexp)
     ("M-<left>"  . sp-backward-barf-sexp)

     ("C-M-t" . sp-transpose-sexp)
     ("C-M-k" . sp-kill-sexp)
     ("C-k"   . sp-kill-hybrid-sexp)
     ("M-k"   . sp-backward-kill-sexp)
     ("C-M-w" . sp-copy-sexp)

     ("C-M-d" . delete-sexp)

     ("M-<backspace>" . backward-kill-word)
     ("C-<backspace>" . sp-backward-kill-word)
     ([remap sp-backward-kill-word] . backward-kill-word)

     ("M-[" . sp-backward-unwrap-sexp)
     ("M-]" . sp-unwrap-sexp)

     ("C-x C-t" . sp-transpose-hybrid-sexp)))
#+END_SRC

** Magit

Git Frontend. [[https://github.com/magit/magit][https://github.com/magit/magit]]

Cheatsheet: [[http://magit.vc/manual/magit-refcard.pdf][http://magit.vc/manual/magit-refcard.pdf]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Magit")
  (use-package magit
               :ensure t
               :config
               (setq magit-auto-revert-mode t))
#+END_SRC


*** Ediff

Stop ediff from opening its interface in a new frame (aka window)

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

** Monky (Magit for Hg)
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Monky")
  (use-package monky
    :ensure t
    :config
    (setq monky-process-type 'cmdserver))
#+END_SRC

** Nyan Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Nyan-mode")
  (use-package nyan-mode
    :ensure t
    :config
    (define-globalized-minor-mode rhol/nyan-mode nyan-mode
      (lambda () (nyan-mode)))
    (rhol/nyan-mode 1))
#+END_SRC

** Auctex

#+BEGIN_SRC emacs-lisp
  (setq zathura-procs ())
  (defun zathura-forward-search ()
    ;; Open the compiled pdf in Zathura with synctex. This is complicated since
    ;; 1) Zathura refuses to acknowledge Synctex directive if the pdf is not
    ;; already opened
    ;; 2) This means we have to bookkeep open Zathura processes ourselves: first
    ;; open a new pdf from the beginning, if it is not already open. Then call
    (interactive)
    (let* ((zathura-launch-buf (get-buffer-create "*Zathura Output*"))
           (pdfname (TeX-master-file "pdf"))
           (zatentry (assoc pdfname zathura-procs))
           (zatproc (if (and zatentry (process-live-p (cdr zatentry)))
                        (cdr zatentry)
                      (progn
                        (let ((proc (progn (message "Launching Zathura")
                                           (start-process "zathura-launch"
                                                          zathura-launch-buf "zathura"
                                                          "-x" "emacsclient +%{line} %{input}" pdfname))))
                          (when zatentry
                            (setq zathura-procs (delq zatentry zathura-procs)))
                          (add-to-list 'zathura-procs (cons pdfname proc))
                          (set-process-query-on-exist-flag proc nil)
                          proc))))
           (synctex (format "%s:0:%s"
                            (TeX-current-line)
                            (TeX-current-file-name-master-relative)))
           )
      (start-process "zathura-synctex" zathura-launch-buf "zathura" "--synctex-forward" synctex pdfname)
      (start-process "raise-zathura-wmctrl" zathura-launch-buf "wmctrl" "-a" pdfname)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Auctex")
  (defun rhol/latex-setup ()
    (setq TeX-parse-self t)
    (setq TeX-save-query nil)
    (setq TeX-PDF-mode t)

    (add-hook 'LaTeX-mode-hook 'visual-line-mode)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

    (setq reftex-plug-into-AUCTeX t)

    ;; setup the viewer
    (if (eq system-type 'darwin)
        (progn
          (setq TeX-view-program-list '())
          (setq TeX-view-program-selection '())
          (add-to-list 'TeX-view-program-list '("skim" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b"))
          (add-to-list 'TeX-view-program-selection '(output-pdf "skim")))
      (progn
        (setq TeX-view-program-selection '())
        (setq TeX-view-program-list '())
        (add-to-list 'TeX-view-program-list '("zathura-custom" zathura-forward-search))
        (add-to-list 'TeX-view-program-selection '(output-pdf "zathura-custom"))))

    ;; Shortcut to jump to line in PDF Viewer
    (add-hook 'LaTeX-mode-hook (lambda () (local-set-key (kbd "<S-s-mouse-1>") #'TeX-view))))

  (use-package latex
    :defer nil
    :config (rhol/latex-setup))

#+END_SRC


*** LatexMk

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Latexmk")
  (use-package auctex-latexmk
               :ensure t
               :ensure-system-package latexmk
               :config
               (auctex-latexmk-setup)
               (add-hook 'TeX-mode-hook '(lambda ()
                                           (setq TeX-command-default "LatexMk"))))
#+END_SRC

** YAML Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Yaml")
  (use-package yaml-mode
    :ensure t
    :mode ("\\.yml$" "\\.yaml$")
    :config
    (add-hook 'yaml-mode '(lambda () (auto-fill-mode -1))))
#+END_SRC

** Markdown Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Markdown Mode")
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . gfm-mode)
	   ("\\.markdown\\'" . gfm-mode))
    :init (setq markdown-command "multimarkdown"))

  ;; Usage Example:
  ;;  
  ;; <!-- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
  ;; <!-- END RECEIVE ORGTBL $1 -->
  ;;  
  ;; <!-- 
  ;; #+ORGTBL: SEND $1 orgtbl-to-gfm
  ;; | $0 | 
  ;; -->

  (defun orgtbl-to-gfm (table params)
    "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown."
    (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
				 org-table-last-alignment ""))
           (params2
           (list
             :splice t
	     :hline (concat alignment "|")
             :lstart "| " :lend " |" :sep " | ")))
      (orgtbl-to-generic table (org-combine-plists params2 params))))
#+END_SRC

** JSON Mode
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :config
    (add-hook 'json-mode '(lambda () (auto-fill-mode -1))))
  (use-package json-reformat
    :ensure t)
#+END_SRC

** GPG
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: EPA")

  (defcustom rhol-gpg-default-key nil
    "Address of default GPG key."
    :type 'string
    :group 'rhol-general
    :group 'rhol-third-party
    :tag "GPG Default Key")

  (if rhol-gpg-default-key
      nil
    (customize-save-variable 'rhol-gpg-default-key (read-string "Enter your GPG email: ")))

  (use-package epa-file
    :config
    (epa-file-enable)
    (setq epa-file-select-keys rhol-gpg-default-key))

  (define-minor-mode sensitive-mode
    "For sensitive files like password lists.
  It disables backup creation and auto saving.

  With no argument, this command toggles the mode.
  Non-null prefix argument turns on the mode.
  Null prefix argument turns off the mode."
    ;; The initial value.
    nil
    ;; The indicator for the mode line.
    " Sensitive"
    ;; The minor mode bindings.
    nil
    (if (symbol-value sensitive-mode)
        (progn
          ;; disable backups
          (set (make-local-variable 'backup-inhibited) t) 
          ;; disable auto-save
          (if auto-save-default
              (auto-save-mode -1)))
                                          ;resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
                                          ;resort to default auto save setting
      (if auto-save-default
          (auto-save-mode 1))))  
  (setq auto-mode-alist
        (append '(("\\.gpg$" . sensitive-mode))
                auto-mode-alist))
#+END_SRC

** Python
*** Pyenv

#+BEGIN_SRC emacs-lisp
  (use-package pyenv-mode
    :ensure t
    :config (pyenv-mode))

  (defun ssbb-pyenv-hook ()
    "Automatically activates pyenv version if .python-version file exists."
    (f-traverse-upwards
     (lambda (path)
       (let ((pyenv-version-path (f-expand ".python-version" path)))
         (if (f-exists? pyenv-version-path)
             (pyenv-mode-set (s-trim (f-read-text pyenv-version-path 'utf-8))))))))

  (add-hook 'find-file-hook 'ssbb-pyenv-hook)
#+END_SRC

*** Elpy

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :init (with-eval-after-load 'python
            (progn              
              (elpy-enable)
              (if (executable-find "ipython")
                  (progn 
                    (elpy-use-ipython)
                    (setq python-shell-interpreter-args (format "%s --simple-prompt" python-shell-interpreter-args))))
              (setq elpy-rpc-backend "jedi")
              (setq elpy-test-runner 'elpy-test-pytest-runner))))
#+END_SRC

*** Autofill comments
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook (lambda () (auto-fill-mode 1)
                                          (setq-local comment-auto-fill-only-comments t)))
#+END_SRC

*** HS Minor Mode

#+BEGIN_SRC emacs-lisp
  (defun rhol/hs-hide (x)
    "Hide block. Or if C-u pressed then hide all"
    (interactive "P")
    (message "%s" x)
    (if x
        (hs-hide-all)
      (hs-hide-block)))

  (defun rhol/hs-show (x)
    "Show block. Or if C-u pressed then show all"
    (interactive "P")
    (message "%s" x)
    (if x
        (hs-show-all)
      (hs-show-block)))

  (add-hook 'python-mode-hook (lambda ()
                                (hs-minor-mode 1)
                                (local-set-key (kbd "C-=") 'rhol/hs-hide)
                                (local-set-key (kbd "C-+") 'rhol/hs-show)))
#+END_SRC

*** Mypy flycheck

#+BEGIN_SRC emacs-lisp
  (message "Loading flycheck-mypy")
  (use-package flycheck-mypy
    :ensure t)
#+END_SRC

** Cmake Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Cmake mode")
  (use-package cmake-mode
    :ensure t
    :config

    ;; I have to do this because I already have .txt files set to org-mode
    ;; in auto-mode-alist
    (add-hook 'org-mode-hook '(lambda ()
                                (let ((filename (buffer-file-name)))
                                  (if (not (eq nil filename))
                                      (let ((basename (car (last (split-string filename "/")))))
                                        (if (string= "CMakeLists.txt" basename)
                                            (cmake-mode))))))))

#+END_SRC

** C/C++ Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: C/C++ Mode")
  (add-to-list 'auto-mode-alist '("\\.h$" . c++-mode))

  (add-hook 'c++-mode-hook 'eldoc-mode)
  (add-hook 'c-mode-hook 'eldoc-mode)
#+END_SRC

*** Clang-format

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/lisp/third-party/clang-format.el")
  (add-hook 'c++-mode-hook '(lambda()
                              (local-set-key (kbd "C-c C-r f") 'clang-format-region)
                              (local-set-key (kbd "C-c C-r b") 'clang-format-buffer)))
#+END_SRC

*** Clang-rename

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/lisp/third-party/clang-rename.el")
  (add-hook 'c++-mode-hook '(lambda() (local-set-key (kbd "C-c C-r r") 'clang-rename)))
#+END_SRC

*** Clang-include-fixer

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/lisp/third-party/clang-include-fixer.el")
#+END_SRC

*** Rtags

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Rtags")
  (use-package rtags 
    :ensure t
    :if (executable-find "rdm")
    :config
    (defun rhol/rtags-hook ()
      (message "rhol/rtags-hook on %s" (buffer-name))
      (rtags-start-process-unless-running)
      (local-set-key (kbd "M-.") 'rtags-find-symbol-at-point)
      (local-set-key (kbd "M-,") 'rtags-find-references-at-point)
      (local-set-key (kbd "C-M-;") 'rtags-find-file)
      (local-set-key (kbd "C-.") 'rtags-find-symbol)
      (local-set-key (kbd "C-,") 'rtags-find-references)
      (local-set-key (kbd "C-<") 'rtags-find-virtuals-at-point)
      (local-set-key (kbd "M-i") 'rtags-imenu)
      (local-set-key (kbd "C-M-,") 'rtags-location-stack-back)
      (local-set-key (kbd "C-M-.") 'rtags-location-stack-forward)
      )
    (add-hook 'c-mode-hook 'rhol/rtags-hook)
    (add-hook 'c++-mode-hook 'rhol/rtags-hook))

#+END_SRC

*** Irony Mode

Eldoc integration

#+BEGIN_SRC emacs-lisp
  (use-package irony-eldoc
    :ensure t
    :config
    (add-hook 'irony-mode-hook 'irony-eldoc))
#+END_SRC

*** hs-mode (code folding)
#+BEGIN_SRC emacs-lisp
  (defun rhol/hs-hook ()
    (hs-minor-mode 1)
    (local-set-key (kbd "C-=") 'hs-hide-block)
    (local-set-key (kbd "C-+") 'hs-show-block)
    )

  (add-hook 'c++-mode-hook 'rhol/hs-hook)
#+END_SRC

*** Compilation Mode improvements

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Compilation mode")
  (setq compilation-scroll-output t)
  (add-hook 'c-mode-common-hook '(lambda () (local-set-key (kbd "<f5>") 'compile)))
#+END_SRC

*** CMake IDE

#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :defer nil)
  (use-package cmake-ide
    :ensure t
    :config
    (cmake-ide-setup))
#+END_SRC

*** Open header files in C++ Mode by default
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.h$" . c++-mode))
#+END_SRC

*** CMake IDE Test Funcs

#+BEGIN_SRC emacs-lisp
  (fset 'original-cmake-ide--get-compile-command (symbol-function 'cmake-ide--get-compile-command))

  (defun rhol/default-cmake-ide-test-func (dir)
    (format "%s test" (original-cmake-ide--get-compile-command dir)))

  (defvar rhol/cmake-ide-test-func
    (symbol-function 'rhol/default-cmake-ide-test-func)
    "Function that receives a directory and returns the test command.")

  (defun cmake-ide--get-compile-command (dir)
    "Return the compile command or the compile and test command.

  DIR: The path to the build folder used by cmake-ide"

    (let ((cmake-compile-command (original-cmake-ide--get-compile-command dir))
          (cmake-test-command (funcall rhol/cmake-ide-test-func dir)))
      (cond ((and (boundp 'rhol/is-test-run) rhol/is-test-run) (format "%s && %s" cmake-compile-command cmake-test-command))
            ((and (boundp 'rhol/is-clean-run) rhol/is-clean-run) (format "%s clean" cmake-compile-command))
            (t cmake-compile-command))))

  (defun cmake-ide-run-tests ()
    "Compile and run test."
    (interactive)
    (let ((rhol/is-test-run t))
      (cmake-ide-compile)))

  (defun cmake-ide-run-clean ()
    "Clean the build directory."
    (interactive)
    (let ((rhol/is-clean-run t))
      (cmake-ide-compile)))
#+END_SRC

*** CMake IDE Clang Include Fixer

clang-include-fixer has a command line arg =-p= that lets you specify
a build directory containing the compile commands and the symbol
database. But the emacs functions don't expose this
argument. Generally would like clang-include-fixer to run using the
cmake-ide-build-dir as the -p argument.

#+BEGIN_SRC emacs-lisp
  (defun cmake-ide-clang-include-fixer ()
    "Invoke the Include Fixer to insert missing C++ headers."
    (interactive)
    (message (concat "Calling the include fixer using cmake-ide-build-dir. "
                     "This might take some seconds. Please wait."))
    (let ((default-directory cmake-ide-build-dir))
      (clang-include-fixer--start #'clang-include-fixer--add-header
                                  "-output-headers")))

  (add-hook 'c++-mode-hook '(lambda() (local-set-key (kbd "C-c C-r i") 'cmake-ide-clang-include-fixer)))
#+END_SRC

*** C++ Mode Hooks

#+BEGIN_SRC emacs-lisp
  (defun rhol/cmakelists-hook ()
    (message "rhol/cmakelists-hook %s" (buffer-name))
    (condition-case ex
        (if (string-equal (buffer-name) "CMakeLists.txt")
            (progn
              (message "buffer is main cmake file")
              (local-set-key (kbd "<f5>") (lambda () cmake-ide-compile))
              (local-set-key (kbd "C-<f5>") 'cmake-ide-run-cmake)
              (local-set-key (kbd "<f6>") 'cmake-ide-run-tests)
              (local-set-key (kbd "C-<f6>") 'cmake-ide-run-clean))
          (message "buffer is not main cmake file"))
      ('error (message "Failed to run rhol/cmakelists-hook on buffer %s. [%s]" (buffer-name) ex))))

  (defun rhol/c++-hook ()
    (message "rhol/c++-hook %s" (buffer-name))
    (condition-case ex
        (progn
          (local-set-key (kbd "<f5>") 'cmake-ide-compile)
          (local-set-key (kbd "C-<f5>") 'cmake-ide-run-cmake)
          (local-set-key (kbd "<f6>") 'cmake-ide-run-tests)
          (local-set-key (kbd "C-<f6>") 'cmake-ide-run-clean))
      ('error (message "Failed to run rhol/c++-hook on buffer %s. [%s]" (buffer-name) ex))))

  (add-hook 'c++-mode-hook 'rhol/c++-hook)
  (add-hook 'cmake-mode-hook 'rhol/cmakelists-hook)
#+END_SRC


** Transpose Frame
Package for rearranging window frames.

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Transpose frame")
  (use-package transpose-frame
    :ensure t
    :demand t
    :config (global-set-key (kbd "C-c t") 'transpose-frame))
#+END_SRC

** Rainbow Delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
** Projectile
Emacs project management.
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Projectile")
  (use-package helm-projectile
    :ensure t)
  (use-package projectile
    :ensure t
    :demand
    :config
    (projectile-global-mode)
    (setq projectile-completion-system 'helm)
    (helm-projectile-on))
#+END_SRC

** ROS
Make Launch files and xacro use xml-mode
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.launch$" . xml-mode))
  (add-to-list 'auto-mode-alist '("\\.xacro$" . xml-mode))
  (add-to-list 'auto-mode-alist '("\\.sdf$" . xml-mode))
  (add-to-list 'auto-mode-alist '("^model\\.config$" . xml-mode))
  (add-to-list 'auto-mode-alist '("\\.world$" . xml-mode))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :mode "\\.rs$"
    :config
    (add-hook 'rust-mode-hook '(lambda ()
                                 (setq-local cargo-compile-command "cargo build")
                                 (setq-local cargo-test-command "cargo test")
                                 (setq-local compilation-read-command nil)
                                 (local-set-key (kbd "<f5>") '(lambda () (interactive) (compile cargo-compile-command)))
                                 (local-set-key (kbd "<f6>") '(lambda () (interactive) (compile cargo-test-command)))))
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode)

    (add-hook 'racer-mode-hook #'company-mode)

    (define-key rust-mode-map (kbd "TAB") #'company-indent-or-complete-common)
    (setq company-tooltip-align-annotations t))

  (use-package cargo
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.toml$" . conf-mode))
    (add-hook 'conf-mode-hook '(lambda () (if (eq "toml" (file-name-extension (buffer-name)))
                                              (progn (cargo-minor-mode 1)                                                   
                                                     (setq-local cargo-compile-command "cargo build")
                                                     (setq-local cargo-test-command "cargo test")
                                                     (setq-local compilation-read-command nil)
                                                     (local-set-key (kbd "<f5>") '(lambda ()
                                                                                    (interactive)
                                                                                    (compile cargo-compile-command)))
                                                     (local-set-key (kbd "<f6>") '(lambda ()
                                                                                    (interactive)
                                                                                    (compile cargo-test-command))))))))
#+END_SRC

** Hydra

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t
    :config
    (require 'hydra-examples)


    (global-set-key
     (kbd "C-n")
     (defhydra hydra-move
       (:pre (progn 
	       (linum-mode 1))
	     :post (linum-mode -1))
       "
     Movement
     ---------
     _n_ next line          _p_ previous line
     _f_ forward char       _b_ backward char
     _a_ beginning of line  _e_ end of line
     _v_ scroll up          _V_ scroll down
     _l_ recenter

     Resize
     ------
     _+_ Zoom In
     _-_ Zoom Out
     _r_ Reset Zoom

     Goto
     ----
     _g_ goto line
     _m_ mark

     _q_ quit
     "
       ("n" next-line)
       ("p" previous-line)
       ("f" forward-char)
       ("b" backward-char)
       ("a" beginning-of-line)
       ("e" move-end-of-line)
       ("v" scroll-up-command)
       ;; Converting M-v to V here by analogy.
       ("V" scroll-down-command)
       ("l" recenter-top-bottom)

       ("+" text-scale-increase "in")
       ("-" text-scale-decrease "out")
       ("r" (text-scale-adjust 0) "reset")

       ("g" goto-line "go")
       ("m" set-mark-command "mark" :bind nil)
       ("q" nil "quit")))

    (defun hydra-move-splitter-left (arg)
      "Move window splitter left."
      (interactive "p")
      (if (let ((windmove-wrap-around))
	    (windmove-find-other-window 'right))
	  (shrink-window-horizontally arg)
	(enlarge-window-horizontally arg)))

    (defun hydra-move-splitter-right (arg)
      "Move window splitter right."
      (interactive "p")
      (if (let ((windmove-wrap-around))
	    (windmove-find-other-window 'right))
	  (enlarge-window-horizontally arg)
	(shrink-window-horizontally arg)))

    (defun hydra-move-splitter-up (arg)
      "Move window splitter up."
      (interactive "p")
      (if (let ((windmove-wrap-around))
	    (windmove-find-other-window 'up))
	  (enlarge-window arg)
	(shrink-window arg)))

    (defun hydra-move-splitter-down (arg)
      "Move window splitter down."
      (interactive "p")
      (if (let ((windmove-wrap-around))
	    (windmove-find-other-window 'up))
	  (shrink-window arg)
	(enlarge-window arg)))

    (global-set-key
     (kbd "C-x w")
     (defhydra hydra-window ()
       "
  Movement^^        ^Split^         ^Switch^      ^Resize^
  ----------------------------------------------------------------
  _j_ left       _|_    vertical      _b_uffer        _J_ left
  _k_ down       _\__   horizontal    _f_ind files    _K_ down
  _i_ up         _z_    undo          _a_ce 1         _I_ up
  _l_ right      _Z_    reset         _s_wap          _L_ right
  _F_ollow      _D_lt   Other        _S_ave          _m_aximize
  _q_ quit      _o_nly  this         _d_elete        _+_   balance
                                     _t_ranspose  
  "
       ("+" balance-windows)
       ("j" windmove-left )
       ("k" windmove-down )
       ("i" windmove-up )
       ("l" windmove-right )
       ("J" hydra-move-splitter-left)
       ("K" hydra-move-splitter-down)
       ("I" hydra-move-splitter-up)
       ("L" hydra-move-splitter-right)
       ("b" helm-mini)
       ("f" helm-find-files)
       ("F" follow-mode)
       ("a" (lambda ()
	      (interactive)
	      (ace-window 1)
	      (add-hook 'ace-window-end-once-hook
			'hydra-window/body))
	)
       ("|" (lambda ()
	      (interactive)
	      (split-window-right)
	      (windmove-right))
	)
       ("_" (lambda ()
	      (interactive)
	      (split-window-below)
	      (windmove-down))
	)
       ("s" (lambda ()
	      (interactive)
	      (ace-window 4)
	      (add-hook 'ace-window-end-once-hook
			'hydra-window/body)))
       ("S" save-buffer)
       ("d" delete-window)
       ("D" (lambda ()
	      (interactive)
	      (ace-window 16)
	      (add-hook 'ace-window-end-once-hook
			'hydra-window/body))
	)
       ("o" delete-other-windows)
       ("m" ace-maximize-window)
       ("t" transpose-frame)
       ("z" (progn
	      (winner-undo)
	      (setq this-command 'winner-undo))
	)
       ("Z" winner-redo)
       ("q" nil)))

    (global-set-key
     (kbd "C-x p")
     (defhydra hydra-projectile (:color teal
					:hint nil)
       "
       PROJECTILE: %(projectile-project-root)

       Find File            Search/Tags          Buffers                Cache
  ------------------------------------------------------------------------------------------
    _f_: file            _a_: ag               _i_: Ibuffer           _c_: cache clear
    _F_: file dwim       _s_: ripgrep          _b_: switch to buffer  _x_: remove known project
  _M-f_: file curr dir   _o_: multi-occur      _K_: Kill all buffers  _X_: cleanup non-existing
    _r_: recent file                                                  _z_: cache current

    _q_: quit
  "
       ("a"    projectile-ag)
       ("b"    projectile-switch-to-buffer)
       ("c"    projectile-invalidate-cache)
       ("f"    projectile-find-file)
       ("F"    projectile-find-file-dwim)
       ("M-f"  projectile-find-file-in-directory)
       ;; ("g"   ggtags-update-tags)
       ;; ("s-g" ggtags-update-tags)
       ("i"   projectile-ibuffer)
       ("K"   projectile-kill-buffers)
       ("o"   projectile-multi-occur)
       ("p"   projectile-switch-project)
       ("r"   projectile-recentf)
       ("s"   projectile-ripgrep)
       ("x"   projectile-remove-known-project)
       ("X"   projectile-cleanup-known-projects)
       ("z"   projectile-cache-current-file)
       ("`"   hydra-projectile-other-window/body "other window")
       ("q"   nil "cancel" :color blue)))


    (global-set-key
     (kbd "C-x SPC")
     (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
					  :color pink
					  :hint nil
					  :post (deactivate-mark))
       "
    ^_k_^       _w_ copy      _o_pen       _N_umber-lines            |\\     -,,,--,,_
  _h_   _l_     _y_ank        _t_ype       _e_xchange-point          /,`.-'`'   ..  \-;;,_
    ^_j_^       _d_ kill      _c_lear      _r_eset-region-mark      |,4-  ) )_   .;.(  `'-'
  ^^^^          _u_ndo        _g_ quit     ^ ^                     '---''(./..)-'(_\_)
  "
       ("k" previous-line)
       ("j" next-line)
       ("h" left-char)
       ("l" right-char)
       ("d" kill-rectangle)                    ;; C-x r k
       ("y" yank-rectangle)                    ;; C-x r y
       ("w" copy-rectangle-as-kill)            ;; C-x r M-w
       ("o" open-rectangle)                    ;; C-x r o
       ("t" string-rectangle)                  ;; C-x r t
       ("c" clear-rectangle)                   ;; C-x r c
       ("e" rectangle-exchange-point-and-mark) ;; C-x C-x
       ("N" rectangle-number-lines)            ;; C-x r N
       ("r" (if (region-active-p)
		(deactivate-mark)
	      (rectangle-mark-mode 1)))
       ("u" undo nil)
       ("g" nil))))
#+END_SRC

** Protobuf
#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :ensure t)
#+END_SRC
** Winner Mode
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure t
    :demand
    :config
    (winner-mode 1))
#+END_SRC
