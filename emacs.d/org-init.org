# -*- coding: utf-8 -*-
#+TITLE: Emacs init file written in org-mode
#+AUTHOR: Devin Schwab
#+EMAIL: digidevin@gmail.com
#+STARTUP: indent

#+BEGIN_SRC emacs-lisp
  (message "Tangling org-init.org file.")
#+END_SRC

* Global Improvements
** Customize Group
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Creating customize group rhol-emacs/rhol-general")
  (defgroup rhol-general nil
    "General customization settings."
    :group 'rhol-emacs
    :tag "General")
#+END_SRC
** Emacs Server

Start Emacs server if not already running.
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Emacs Server")
  (add-hook 'after-init-hook
            (lambda ()
              "Start Emacs server if not already running."
              (use-package server
                :config
                (unless (server-running-p)
                  (server-start)))))
#+END_SRC
** Bash Environment
Set Emacs environment variables to the same values that a user would
have after sourcing .bash_profile.
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Bash Environment")

  (defun rhol--get-bash-env ()
    "Return the environment variable string set by .bash_profile."
    (shell-command-to-string "/bin/bash -c \"source ~/.bash_profile; env\""))

  (defun rhol--apply-env-string (raw-env-str)
    "Set environment variables from env string.
  
    RAW-ENV-STR the output of env command"
    (let ((env-strings (split-string raw-env-str "\n")))
      (setq process-environment env-strings)))

  (defun rhol-eval-bash-env ()
    "Overwrite `process-environment' with the environment variables set by .bash_profile."
    (interactive)
    (rhol--apply-env-string (rhol--get-bash-env)))

  (defun rhol--get-bash-path ()
    "Return PATH variable after evaluating bash profile."
    (replace-regexp-in-string "\n" ""
                              (shell-command-to-string "/bin/bash -c \"source ~/.bash_profile >/dev/null 2>&1; echo $PATH\"")))

  (defun rhol-eval-bash-path ()
    "Set exec path based on bash path variable."
    (interactive)
    (let ((env-strings (split-string (rhol--get-bash-path) ":")))
      (setq exec-path env-strings)))

  (rhol-eval-bash-env)
  (rhol-eval-bash-path)
#+END_SRC

** Open Default Directory

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Open Default Directory")

  (defun rhol-open-default-directory ()
    "Open the directory of the current buffer.

    Useful for quickly opening a dired buffer for the containing
    folder of the current buffer."
    (interactive)
    (find-file (file-name-directory buffer-file-name)))

  (global-set-key (kbd "C-x C-j") 'rhol-open-default-directory)
#+END_SRC
** General Keybindings

Useful key bindings. Deals with clipboard integration and
disabling C-z.

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: General Keybindings")
  ;; unbind the sleep button
  (global-unset-key [(control z)])
  (global-unset-key [(control x)(control z)])

  ;; Windows Style undo
  (global-set-key (kbd "s-z") 'undo)

  ;; Windows Style cut, copy and paste
  (global-set-key (kbd "s-c") 'clipboard-kill-ring-save)
  (global-set-key (kbd "s-x") 'clipboard-kill-region)
  (global-set-key (kbd "s-v") 'clipboard-yank)

  ;; quickly enable and disable auto-fill-mode
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC

** Common Lisp Package

Required library for a lot of the packages in the following sections.

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Common Lisp package")
  (use-package cl
    :ensure t)
#+END_SRC
** General Tweaks

Lots of handy little quality of life improvements.

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: General Tweaks")
  ;; enable line highlighting
  (global-hl-line-mode t)

  ;; get rid of yes or no prompt
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; remove confirmation if file or buffer does not exist
  (setq confirm-nonexistent-file-or-buffer nil)
  ;; remove splash screen and echo area message
  (setq inhibit-startup-message t inhibit-startup-echo-area-message t)

  ;; Add autofill for all text mode buffers
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Sudo Edit

When a buffer requires sudo privileges to edit, this function allows
the user to press =C-x C-r= to reload the buffer with sudo privileges.
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Sudo Edit")
  ;; Allow editing of a buffer that requires sudo privileges
  (defun sudo-edit (&optional arg)
    "Edit currently visited file as root.

  With a prefix ARG prompt for a file to visit.
  Will also prompt for a file to visit if current
  buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (ido-read-file-name "Find file(as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
  (global-set-key (kbd "C-x C-r") 'sudo-edit)
#+END_SRC
** Spellcheck
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Spellcheck")

  (defcustom rhol-default-spellchecker "hunspell"
    "Executable name for default spellchecker."
    :type '(choice (string :tag "hunspell" :value "hunspell")
                   (string :tag "aspell" :value "aspell")
                   (string :tag "Custom"))
    :group 'rhol-general
    :tag "Default spellchecker")

  (defcustom rhol-default-spellchecker-args '("-d en_US")
    "List of extra args to provide to spellchecker."
    :type 'list
    :group 'rhol-general
    :tag "Default spellchecker args")

  (defun rhol--config-spellchecker ()
    "Configure spellchecker using saved config."
    (if (executable-find rhol-default-spellchecker)
        (progn
          (setq ispell-program-name rhol-default-spellchecker)
          (setq ispell-extra-args rhol-default-spellchecker-args)
          (if (string= "aspell" rhol-default-spellchecker)
              (setq ispell-list-command "--list")))
      (user-error "Default spellchecker %s not found" rhol-default-spellchecker)))

  (rhol--config-spellchecker)
#+END_SRC
* Appearance
** Customize Group
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Creating customize group rhol-emacs/rhol-appearance")
  (defgroup rhol-appearance nil
    "Appearance customization settings."
    :group 'rhol-emacs
    :tag "Appearance")
#+END_SRC
** Font
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Font")

  (defcustom rhol-default-font nil
    "Font name used in graphical mode."
    :type 'string
    :group 'rhol-appearance
    :tag "Default Font")

  (if rhol-default-font
      nil
    (customize-save-variable 'rhol-default-font
                             (let ((choice (completing-read "What font do you want to use? ((D)efault, (I)nconsolata, (S)ource Code Pro, (O)ther): "
                                                            '(("D" 1)
                                                              ("I" 2)
                                                              ("S" 3)
                                                              ("O" 4))
                                                            nil t "D")))
                               (cond
                                ((string= choice "D")
                                 "DejaVu Sans Mono")
                                ((string= choice "I")
                                 "Inconsolata")
                                ((string= choice "S")
                                 "Source Code Pro")
                                ((string= choice "O")
                                 (read-string "Enter desired font-name: "))))))

  (defcustom rhol-default-font-size nil
    "Font size used in graphical mode."
    :type 'integer
    :group 'rhol-appearance
    :tag "Font Size")

  (if rhol-default-font-size
      nil
    (customize-save-variable 'rhol-default-font-size
                             (read-number "Enter font size: " 9)))

  (defun rhol--configure-font ()
    "Refresh font configuration."
    (if (member rhol-default-font (font-family-list))
        (let ((font-name (format "%s-%d" rhol-default-font rhol-default-font-size)))
        (add-to-list 'initial-frame-alist (cons 'font font-name))
        (add-to-list 'default-frame-alist (cons 'font font-name)))
      (user-error "Font %s does not exist" rhol-default-font)))

  (rhol--configure-font)
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Theme")
  (use-package darkokai-theme
    :ensure t
    :config
    (add-to-list 'custom-safe-themes "196cc00960232cfc7e74f4e95a94a5977cb16fd28ba7282195338f68c84058ec")
    (load-theme 'darkokai-custom t))
#+END_SRC
** Emojis

#+BEGIN_SRC emacs-lisp
  (message "loading emojify")
  (use-package emojify
    :ensure t
    :config
    (emojify-download-emoji-maybe)
    (add-hook 'after-init-hook #'global-emojify-mode))
#+END_SRC
** Disable Toolbars

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)
#+END_SRC
* Third-Party Packages
** Customize Group
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Creating customize group rhol-emacs/rhol-appearance")
  (defgroup rhol-third-party nil
    "Enable and disable third-party packages."
    :group 'rhol-emacs
    :tag "Third-Party Packages")
#+END_SRC
** ibuffer

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: ibuffer")
  (defcustom rhol-use-ibuffer t
    "Set true to enable ibuffer package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use ibuffer")

  (if rhol-use-ibuffer
      (use-package ibuffer
        :ensure t
        :config
        (global-set-key (kbd "C-x C-b") 'ibuffer)
        (setq ibuffer-saved-filters
              '(("C/C++" ((or (mode . c++-mode)
                              (mode . c-mode)
                              (mode . cmake-mode))))
                ("Python" ((mode . python-mode)))
                ("Emacs" ((or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$"))))
                ("Org" ((or
                         (name . "^\\*Org Agenda\\*$")
                         (mode . org-mode))))
                ("Dired" ((mode . dired-mode)))
                ("Helm" ((name . "^\\*helm")))
                ("Magit" ((name . "^\\*magit")))))
        (setq ibuffer-saved-filter-groups
              '(("Default"
                 ("Dired" (mode . dired-mode))
                 ("Python" (mode . python-mode))
                 ("Org" (or
                         (name . "^\\*Org Agenda\\*$")
                         (mode . org-mode)))
                 ("C/C++" (or
                           (mode . c++-mode)
                           (mode . c-mode)
                           (mode . cmake-mode)))
                 ("Emacs" (or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$")))
                 ("Helm" (name . "^\\*helm"))
                 ("Magit" (name . "^\\*magit")))))
        (add-hook 'ibuffer-mode-hook (lambda () (ibuffer-switch-to-saved-filter-groups "Default")))))
#+END_SRC
** Direnv

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: direnv")
  (defcustom rhol-use-direnv t
    "Set true to enable direnv parsing."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use direnv")

  (defun rhol--find-envrc (path)
    "Find path to .envrc.

    PATH path to the buffer that you want to find .envrc for."
    (locate-dominating-file path ".envrc"))

  (defun rhol--get-direnv-str (envrc-path)
    "Get the direnv environment vars.

    ENVRC-PATH path to the .envrc to load."
    (message "%s" envrc-path)
    (make-local-variable 'process-environment)
    (shell-command-to-string (format "pushd %s > /dev/null; source .envrc; /usr/bin/env" envrc-path)))

  (defun rhol-unload-direnv ()
    "Unload changed env from direnv."
    (interactive)
    (if (local-variable-p 'process-environment)
        (kill-local-variable 'process-environment)))

  (defun rhol-load-direnv-for-buffer ()
    "Parse environment specified by direnv for a given buffer."
    (interactive)
    (cond
     ;; Special handling of dired mode files
     ((eq 'dired-mode major-mode)
      (let ((envrc-path (rhol--find-envrc (expand-file-name default-directory))))
        (message "%s" envrc-path)
        (if envrc-path
            (let ((env-str (rhol--get-direnv-str envrc-path)))
              (message "%s" env-str)
              (rhol--apply-env-string env-str)))))
     ;; Other files can be handled normally
     (t
      (let ((envrc-path (rhol--find-envrc (buffer-file-name))))
        (if envrc-path
            (let ((env-str (rhol--get-direnv-str envrc-path)))
              ;; (message "%s" env-str)
              (rhol--apply-env-string env-str)))))))

  (if rhol-use-direnv
      (add-hook 'find-file-hook 'rhol-load-direnv-for-buffer))
#+END_SRC
** Ace Window
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: ace-window")
  (defcustom rhol-use-ace-window t
    "Set true to enable ace-window package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use ace-window")
  (if rhol-use-ace-window
      (use-package ace-window
        :ensure t))
#+END_SRC
** Ripgrep

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: ripgrep")
  (defcustom rhol-use-ripgrep t
    "Set true to enable ripgrep package if rg installed on system."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use ripgrep")
  (if rhol-use-ripgrep
      (if (executable-find "cargo")
          (use-package rg
            :ensure t
            :ensure-system-package 
            (rg . "cargo install --force ripgrep")
            :config (rg-enable-default-bindings))
        (message "cargo not installed. Skipping rg package.")))
#+END_SRC
** Flyspell
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: flyspell")
  (defcustom rhol-use-flyspell t
    "Set true to enable flyspell package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use flyspell")
  (if rhol-use-flyspell
      (use-package flyspell
        :ensure t
        :config (add-hook 'org-mode-hook '(lambda () (flyspell-mode)))))
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Flycheck")

  (defcustom rhol-use-flycheck t
    "Set true to enable flycheck package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Use flycheck")

  (if rhol-use-flycheck
      (use-package flycheck
        :ensure t
        :config
        (add-hook 'after-init-hook #'global-flycheck-mode)))
#+END_SRC

** YASnippets

Autofill snippets for various modes.
[[https://capitaomorte.github.io/yasnippet/][https://capitaomorte.github.io/yasnippet/]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: YASnippets")
    (defcustom rhol-use-yasnippet t
      "Set true to enable yasnippet package."
      :type 'boolean
      :group 'rhol-third-party
      :tag "Use yasnippet")

  (if rhol-use-yasnippet
      (use-package yasnippet
        :ensure t
        :config
        (yas-global-mode 1)
        (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")))
#+END_SRC

** Company

Autocomplete module. See [[https://company-mode.github.io/][https://company-mode.github.io/]]


#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Company")

  (defcustom rhol-use-company t
    "Enable use of company package."
    :type 'boolean
    :group 'rhol-third-party
    :tag "Enable company")

  (if rhol-use-company
      (use-package company
        :ensure t
        :config
        (setq company-idle-delay 0.5)
        (add-hook 'after-init-hook 'global-company-mode)
        (global-set-key (kbd "C-<tab>") 'company-complete-common)
        (company-auctex-init)
        (add-to-list 'company-backends 'company-math-symbols-unicode)))

#+END_SRC
** Helm

Auto-completion library
[[https://emacs-helm.github.io/helm/][https://emacs-helm.github.io/helm/]]

*** Basic Config

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Helm")
  (defun rhol/helm-config ()
    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z") 'helm-select-action)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-split-window-in-side-p           t ; open helm buffer inside current window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when
                                          ;      reaching top or bottom of source
          helm-ff-search-library-in-sexp        t ; search for library in `require` and `declare-function` sexp
          helm-scroll-amount                    8 ; scroll 8 lines
          helm-ff-file-name-history-use-recentf t)

    (helm-mode 1)

    ;; Replace normal M-x
    (global-set-key (kbd "M-x") 'helm-M-x)
    (setq helm-M-x-fuzzy-match t)

    ;; Replace normal kill-ring cycle
    (global-set-key (kbd "M-y") 'helm-show-kill-ring)

    ;; Replace normal find files
    (global-set-key (kbd "C-x C-f") 'helm-find-files))

  (use-package helm
    :ensure t
    :config
    (use-package helm-config)
    (rhol/helm-config))
#+END_SRC

*** Helm swoop

Buffer search with Helm
[[https://github.com/ShingoFukuyama/helm-swoop][https://github.com/ShingoFukuyama/helm-swoop]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Helm Swoop")
  (use-package helm-swoop
    :ensure t
    :config
    (global-set-key (kbd "M-i") 'helm-swoop)
    (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
    (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
    (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch) ; when doing isearch, hand the word over to helm-swoop
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
#+END_SRC

** Smartparens

Smartparens is a minor mode for dealing with pairs of delimiters. More
info can be found at [[https://github.com/Fuco1/smartparens][https://github.com/Fuco1/smartparens]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Smartparens")
  (use-package smartparens-config
    :ensure smartparens
    :config
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)
    (defun wrap-with-parens ()
      (sp-wrap-with-pair "("))
    (bind-keys
     :map smartparens-mode-map
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)

     ("C-<down>" . sp-down-sexp)
     ("C-<up>"   . sp-up-sexp)
     ("M-<down>" . sp-backward-down-sexp)
     ("M-<up>"   . sp-backward-up-sexp)

     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)

     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)

     ("C-S-f" . sp-forward-symbol)
     ("C-S-b" . sp-backward-symbol)

     ("C-<right>" . sp-forward-slurp-sexp)
     ("M-<right>" . sp-forward-barf-sexp)
     ("C-<left>"  . sp-backward-slurp-sexp)
     ("M-<left>"  . sp-backward-barf-sexp)

     ("C-M-t" . sp-transpose-sexp)
     ("C-M-k" . sp-kill-sexp)
     ("C-k"   . sp-kill-hybrid-sexp)
     ("M-k"   . sp-backward-kill-sexp)
     ("C-M-w" . sp-copy-sexp)

     ("C-M-d" . delete-sexp)

     ("M-<backspace>" . backward-kill-word)
     ("C-<backspace>" . sp-backward-kill-word)
     ([remap sp-backward-kill-word] . backward-kill-word)

     ("M-[" . sp-backward-unwrap-sexp)
     ("M-]" . sp-unwrap-sexp)

     ("C-x C-t" . sp-transpose-hybrid-sexp)))
#+END_SRC

** Magit

Git Frontend. [[https://github.com/magit/magit][https://github.com/magit/magit]]

Cheatsheet: [[http://magit.vc/manual/magit-refcard.pdf][http://magit.vc/manual/magit-refcard.pdf]]

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Magit")
  (use-package magit
               :ensure t
               :config
               (setq magit-auto-revert-mode t))
#+END_SRC


*** Ediff

Stop ediff from opening its interface in a new frame (aka window)

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

** Monky (Magit for Hg)
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Monky")
  (use-package monky
    :ensure t
    :config
    (setq monky-process-type 'cmdserver))
#+END_SRC

** Nyan Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Nyan-mode")
  (use-package nyan-mode
    :ensure t
    :config
    (define-globalized-minor-mode rhol/nyan-mode nyan-mode
      (lambda () (nyan-mode)))
    (rhol/nyan-mode 1))
#+END_SRC

** Auctex

#+BEGIN_SRC emacs-lisp
  (setq zathura-procs ())
  (defun zathura-forward-search ()
    ;; Open the compiled pdf in Zathura with synctex. This is complicated since
    ;; 1) Zathura refuses to acknowledge Synctex directive if the pdf is not
    ;; already opened
    ;; 2) This means we have to bookkeep open Zathura processes ourselves: first
    ;; open a new pdf from the beginning, if it is not already open. Then call
    (interactive)
    (let* ((zathura-launch-buf (get-buffer-create "*Zathura Output*"))
           (pdfname (TeX-master-file "pdf"))
           (zatentry (assoc pdfname zathura-procs))
           (zatproc (if (and zatentry (process-live-p (cdr zatentry)))
                        (cdr zatentry)
                      (progn
                        (let ((proc (progn (message "Launching Zathura")
                                           (start-process "zathura-launch"
                                                          zathura-launch-buf "zathura"
                                                          "-x" "emacsclient +%{line} %{input}" pdfname))))
                          (when zatentry
                            (setq zathura-procs (delq zatentry zathura-procs)))
                          (add-to-list 'zathura-procs (cons pdfname proc))
                          (set-process-query-on-exist-flag proc nil)
                          proc))))
           (synctex (format "%s:0:%s"
                            (TeX-current-line)
                            (TeX-current-file-name-master-relative)))
           )
      (start-process "zathura-synctex" zathura-launch-buf "zathura" "--synctex-forward" synctex pdfname)
      (start-process "raise-zathura-wmctrl" zathura-launch-buf "wmctrl" "-a" pdfname)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Auctex")
  (defun rhol/latex-setup ()
    (setq TeX-parse-self t)
    (setq TeX-save-query nil)
    (setq TeX-PDF-mode t)

    (add-hook 'LaTeX-mode-hook 'visual-line-mode)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

    (setq reftex-plug-into-AUCTeX t)

    ;; setup the viewer
    (if (eq system-type 'darwin)
        (progn
          (setq TeX-view-program-list '())
          (setq TeX-view-program-selection '())
          (add-to-list 'TeX-view-program-list '("skim" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b"))
          (add-to-list 'TeX-view-program-selection '(output-pdf "skim")))
      (progn
        (setq TeX-view-program-selection '())
        (setq TeX-view-program-list '())
        (add-to-list 'TeX-view-program-list '("zathura-custom" zathura-forward-search))
        (add-to-list 'TeX-view-program-selection '(output-pdf "zathura-custom"))))

    ;; Shortcut to jump to line in PDF Viewer
    (add-hook 'LaTeX-mode-hook (lambda () (local-set-key (kbd "<S-s-mouse-1>") #'TeX-view))))

  (use-package latex
    :defer nil
    :config (rhol/latex-setup))

#+END_SRC


*** LatexMk

#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Latexmk")
  (use-package auctex-latexmk
               :ensure t
               :ensure-system-package latexmk
               :config
               (auctex-latexmk-setup)
               (add-hook 'TeX-mode-hook '(lambda ()
                                           (setq TeX-command-default "LatexMk"))))
#+END_SRC

** YAML Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Yaml")
  (use-package yaml-mode
    :ensure t
    :mode ("\\.yml$" "\\.yaml$")
    :config
    (add-hook 'yaml-mode '(lambda () (auto-fill-mode -1))))
#+END_SRC

** Markdown Mode
#+BEGIN_SRC emacs-lisp
  (message "org-init.org: Markdown Mode")
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . gfm-mode)
	   ("\\.markdown\\'" . gfm-mode))
    :init (setq markdown-command "multimarkdown"))

  ;; Usage Example:
  ;;  
  ;; <!-- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
  ;; <!-- END RECEIVE ORGTBL $1 -->
  ;;  
  ;; <!-- 
  ;; #+ORGTBL: SEND $1 orgtbl-to-gfm
  ;; | $0 | 
  ;; -->

  (defun orgtbl-to-gfm (table params)
    "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown."
    (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
				 org-table-last-alignment ""))
           (params2
           (list
             :splice t
	     :hline (concat alignment "|")
             :lstart "| " :lend " |" :sep " | ")))
      (orgtbl-to-generic table (org-combine-plists params2 params))))
#+END_SRC
